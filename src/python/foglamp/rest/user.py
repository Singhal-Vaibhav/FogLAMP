"""
The User correlates to the following list of tables: 
-- users:                           provide information regarding a given user 
-- user_login:                      provide information regarding logging into the system 
-- roles:                           provide information regarding a given role 
-- user_asset_permissions:          provide information regarding which assets user has access to          
-- user_resource_permissions:       provide information regarding which resouces user has access to
-- role_asset_permissions:          provide information regarding which assets a role has access to
-- role_resource_permission:        provide information regarding which resouces a role has access to

Questions: 
1. Can a user with a given role has different permissions than his/her role? 
2. for users.uid is that unique, or can 2 users have the same name 

Relationship 
users.id is referenced by: 
- user_asset_permissions.user_id 
- user_logins.user.id 
- user_resource_permissions.user_id 

roles.id is refrenced by: 
- users.role_id
"""

import aiocoap.resource as resource
import psycopg2
import aiopg.sa
import logging
import sqlalchemy as sa
from cbor2 import loads
import foglamp.model.config as config
import aiocoap


# Validate SQL - https://stackoverflow.com/questions/20718469/validation-in-sqlalchemy

class TestUser:
    def __init__(self):
        self.user=User()

    def test_insert_role(self):
        """
        Validate that an Insert works 
        Returns:
        """
        # should fail because table not expected
        self.user.insert_row(table='role',columnValues={'id':1234,'name':'qa','description':'test product'})
        # should fail because column not expected
        self.user.insert_row(table='role', column={'id': 1234, 'name': 'qa', 'description': 'test product'})
        # should pass
        self.user.insert_row(tableName='role', columnValues={'id': 1234, 'name': 'qa', 'description': 'test product'})

    def test_update_row(self):
        """
        validate that an update works 
        Returns:
        """
        # Test 1 for 1
        self.user.update_row(tableName='role',updateValues={'description': 'create new tests'},whereValues={'id': 1234})
        # Test 2 for 1
        self.user.update_row(tableName='role',updateValues={'name':'test developer','description':'create new tests'},
                             whereValues={'id':1234})
        # Test 1 for 2
        self.user.update_row(tableName='role',updateValues={'description': 'create new tests'},
                             whereValues={'id': 1234,'name':'qa'})

    def test_remove_row(self):
        # only table name and data
        self.user.remove_row(tableName='role',whereValue={'id':1234})
        # only table name
        self.test_remove_row(tableName='role')

    def test_select_all_roles(self):
        """
        validate that SELECT *
        """
        # should fail because table not expected
        self.user.select_all(table='role')
        # should pass
        self.user.select_all(tableName='role')

class User:
    def __init__(self):
        super(User, self).__init__()

    async def _execute_query(self,stmt):
        """
        Execute stmt generated by one of the other methods
            This is a prive method 
        Args:
            stmt: 

        Returns:

        """
        async with aiopg.sa.create_engine(config.db_connection_string) as engine:
            async with engine.aquire() as conn:
                try:
                    await conn.execute(stmt)
                except psycopg2.IntegrityError as e:
                    logging.getLogger('user-data').exception("Unable to execute query against user/role data")
        return aiocoap.Message(payload=''.encode('utf-8'))

    async def insert_row(self,**kwargs):
        """
        based on the information provided by user insert rows 
            User should provide: tableName, and columnValues which is a dict containing both column [key] and values
        Args:
            **kwargs: 
        Returns:
            aiocoap.Message
        """
        command = kwargs
        # Verify user specified something 'expected'
        if sorted(command.keys()) != sorted(['tableName', 'columnValues']):
            print("Error Unexpected Keys")
            return

        # Prepare insert stmt
        stmt="INSERT INTO {} ({}) VALUES ({});"
        columnNames=""
        columnValues=""
        for key in command['columnValues'].keys():
            columnNames+=key+","
            if (type(command['columnValues'][key]) is not float) and (type(command['columnValues'][key]) is not int):
                columnValues+="'"+str(command['columnValues'][key])+"',"
            else:
                columnValues +=str(command['columnValues'][key])+","
        stmt = stmt.format(command['tableName'],columnNames[:-1],columnValues[:-1])
        
        # Execute Insert stmt
        return self._execute_query(stmt)

    async def update_row(self,**kwargs):
        """
        Update specific row(s) for table based on WHERE condition
            User should provide: tableName, updateColumn dict containing updating column name [key] and value,
                                  whereColumn containing column name [key] and value 
        Args:
            **kwargs: 
        Returns:
            aiocoap.Message(payload=''.encode('utf-8'))
        """
        command = kwargs
        stmt = "UPDATE {} SET {} WHERE {}"
        updateColumn=""
        whereColumn=""

        # Check for appropriate information
        if sorted(command.keys()) != sorted(['tableName','updateColumn','whereColumn']):
            print ("Error Unexpected Key")
            return

        #Prepare update statement
        for column in command['updateColumn'].keys():
            if (type(command['updateColumn'][column]) is not float) and (type(command['updateColumn'][column]) is not int):
                updateColumn+=column+"='"+command['updateColumn'][column]+"',"
            else:
                updateColumn+=column+"="+str(command['updateColumn'][column])+","
        for column in command['whereColumn'].keys():
            if (type(command['whereColumn'][column]) is not float) and (type(command['whereColumn'][column]) is not int):
                whereColumn+=column+"='"+command['whereColumn'][column]+"' AND "
            else:
                whereColumn+=column+"="+str(command['whereColumn'][column])+","
        stmt = stmt.format(command['tableName'], updateColumn[:-1], whereColumn.rsplit('AND', 1)[0])

        # Execute statement
        return self._execute_query(stmt)

    async def remove_row(self,**kwargs):
        command = kwargs
        stmt = "DELETE FROM {} WHERE {}"
        whereColumn=""
        if sorted(command.keys()) == sorted(['tableName']):
            stmt = stmt.rsplit("WHERE",1)[0].format(command['tableName'])
            return self._execute_query(stmt)

        elif sorted(command.keys()) != sorted(['tableName','whereColumn']):
            print ("Error Unexpected Key")
            return

        # Prepare update statement
        for column in command['whereColumn'].keys():
            if (type(command['whereColumn'][column]) is not float) and (type(command['whereColumn'][column]) is not int):
                whereColumn+=column+"='"+command['whereColumn'][column]+"' AND "
            else:
                whereColumn+=column+"="+str(command['whereColumn'][column])+","
        stmt = stmt.format(command['tableName'], whereColumn.rsplit('AND', 1)[0])

        # Execute statement
        return self._execute_query(stmt)

    async def select_all(self, **kwargs):
        """
        Retrieve all rows from given table
            User should provide: tableName
        Args:
            **kwargs: 
        Returns:
            aiocoap.Message
        """
        command = kwargs
        stmt = "SELECT * FROM {}"
        if sorted(command.keys()) != sorted(['tableName']):
            print("Error Unexpected Key")
            return

        stmt = stmt.format(command['tableName'])
        return self._execute_query(stmt)

